[
   {
      "author": "pmfoysal",
      "date": 1652140800000,
      "title": "How will you implement a search to find products by name?",
      "image": "https://raw.githubusercontent.com/pmfoysal/data/main/images/blog-005.jpg",
      "body": "Creating a JavaScript list filter and searching for records is one of the fundamental skills for web developers. Filtering means that we make a list of records shorter, more adjusted to the user's wishes, using some known values. Search means that we are using unknown search terms to find records in the list, or database. We are used to searching so much that a lot of pages offer just search, without filtering, categories. We show you how to use both, which technique you will use, is up to you. <br /> <br /> How can we filter and search in JavaScript using: <br /> <strong>1. </strong> Array.filter <br /> <strong>2. </strong> Array.find <br /> <strong>3. </strong> loops <br /> <strong>4. </strong> Array.includes <br /> <strong>5. </strong> Array.findIndex"
   },
   {
      "author": "pmfoysal",
      "date": 1646179200000,
      "title": "How does prototypical inheritance work?",
      "image": "https://raw.githubusercontent.com/pmfoysal/data/main/images/blog-003.jpg",
      "body": "JavaScript is a prototype-based, Object Oriented programming language. After the ES6 updates, JavaScript allowed for “prototypal inheritance”, meaning that objects and methods can be shared, extended, and copied. Sharing amid objects makes for easy inheritance of structure (data fields), behavior (functions / methods), and state (data values). JavaScript is the most common of the prototype-capable languages, and its capabilities are relatively unique. When used appropriately, prototypical inheritance in JavaScript is a powerful tool that can save hours of coding. <br /> <br /> Simply put, prototypical inheritance refers to the ability to access object properties from another object. We use a JavaScript prototype to add new properties and methods to an existing object constructor. We can then essentially tell our JS code to inherit properties from a prototype. Prototypical inheritance allows us to reuse the properties or methods from one JavaScript object to another through a reference pointer function."
   },
   {
      "author": "pmfoysal",
      "date": 1653436800000,
      "title": "Why you do not set products = [...] instead, you use the setProducts",
      "image": "https://raw.githubusercontent.com/pmfoysal/data/main/images/blog-006.jpg",
      "body": "Whoever worked or learned a bit of React probably knows that we should never change or update the state  directly. Rather we should always declare a new object const obj = {} and use setState(value) and let  react handle it, just like I did in the example below. But why?  <br />  <br />  <strong># React has three lifecycle phases:</strong> <br />  1. Mounting Phase: When the component is mounted for the first time. It has three lifecycle hooks that we  commonly use: <br />  i. constructor <br /> ii. render <br /> ii. componentDidMount  <br />  <br />  <strong># Updating Phase</strong> <br />  When the component is already mounted and a change in state or props has happened. It has two lifecycle  hooks that we commonly use: <br /> i. render <br /> ii. componentDidUpdate <br />  <br />  <strong># Unmounting Phase</strong> <br />  When a component is deleted. It has one lifecycle hook that we commonly use: i. componentWillUnmount  <br />  <br />  All these lifecycle hooks are called in order. If you don't know what a Stateless functional component is,  its a component that has no state or constructor or any lifecycle hooks and are fully controlled by their  parents. They only render a react component."
   },
   {
      "author": "pmfoysal",
      "date": 1651104000000,
      "title": "What is a unit test? Why should write unit tests?",
      "image": "https://raw.githubusercontent.com/pmfoysal/data/main/images/blog-004.jpg",
      "body": "UNIT TESTING is a type of software testing where individual units or components of a software are tested.  The purpose is to validate that each unit of the software code performs as expected. Unit Testing is done  during the development (coding phase) of an application by the developers. Unit Tests isolate a section of  code and verify its correctness. A unit may be an individual function, method, procedure, module, or  object. In SDLC, STLC, V Model, Unit testing is first level of testing done before integration testing.  Unit testing is a WhiteBox testing technique that is usually performed by the developer. Though, in a  practical world due to time crunch or reluctance of developers to tests, QA engineers also do unit  testing.  <br />  <br />  <strong># Why Unit Tests:</strong> <br />  <strong>1. </strong> Unit tests save time and money. Usually, we tend to test the happy path more than the  unhappy path. If you release such an app without thorough testing, you would have to keep fixing issues  raised by your potential users. The time to fix these issues could've been used to build new features or  optimize the existing system. Bear in mind that fixing bugs without running tests could also introduce new  bugs into the system. <br />  <strong>2. </strong> Well-written unit tests act as documentation for your code. Any developer can quickly  look at your tests and know the purpose of your functions. <br />  <strong>3. </strong> It simplifies the debugging process. <br />  <strong>4. </strong> Unit testing is an integral part of extreme programming. Extreme programming is  basically a “test-everything-that-can-possibly-break” programming strategy. <br />  <strong>5. </strong> Unit tests make code reuse easier. If you want to reuse existing code in a new  project, you can simply migrate both the code and tests to your new project, then run your tests to make  sure you have the desired results. <br />  <strong>6. </strong> Unit testing improves code coverage. A debatable topic is to have 100% code coverage  across your application."
   },
   {
      "author": "pmfoysal",
      "date": 1644451200000,
      "title": "What are the different ways to manage a state in a React application?",
      "image": "https://raw.githubusercontent.com/pmfoysal/data/main/images/blog-002.jpg",
      "body": "When we talk about state in our applications, it's important to be clear about what types of state  actually matter. There are four main types of state you need to properly manage in your React apps:  <br />  <br />  1. Local State <br />  2. Global State <br />  3. Server State <br />  4. URL State  <br />  <br />  <strong># Local State</strong> <br />  Local state is data we manage in one or another component. Local state is most often managed in React  using the useState hook.  <br />  <br />  <strong># Global State</strong> <br />  Global state is data we manage across multiple components. Global state is necessary when we want to get  and update data anywhere in our app, or in multiple components at least.  <br />  <br />  <strong>1. useContext</strong> <br />  useContext hook is used to create common data that can be accessed throughout the component hierarchy  without passing the props down manually to each level. Context defined will be available to all the child  components without involving props.  <br />  <br />  <strong>2. Redux</strong> <br />  Redux is a tool that comes to solve both of the problems mentioned before (prop drilling and unpredictable  state behavior on frequent and complex state changes). The Redux set of tools is very similar to what  we've just seen with useReducer, but with a few more things. There are three main building blocks in  Redux: (<strong>Store, Reducer, Action</strong>)  <br />  <br />  <strong>3. Redux Toolkit</strong> <br />  Redux toolkit is a library built on top of Redux, which aims to take away some of the complexity and  boilerplate that Redux generates. Redux toolkit is built upon two things:  <br />  <br />  <strong># Server State</strong> <br />  Data that comes from an external server that must be integrated with our UI state. Server state is a  simple concept, but can be hard to manage alongside all of our local and global UI state.  <br />  <br />  <strong># URL State</strong> <br />  Data that exists on our URLs, including the pathname and query parameters. URL state is often missing as a  category of state, but it is an important one. In many cases, a lot of major parts of our application rely  upon accessing URL state. Try to imagine building a blog without being able to fetch a post based off of  its slug or id that is located in the URL!"
   },
   {
      "author": "pmfoysal",
      "date": 1643068800000,
      "title": "How will you improve the performance of a React Application?",
      "image": "https://raw.githubusercontent.com/pmfoysal/data/main/images/blog-001.jpg",
      "body": "React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. While this will lead to a faster user interface without specifically optimizing for performance for many cases, there are ways where you can still speed up your React application. This post will go over some useful techniques you can use to improve your React code. <br /> <br /> <strong># Using Immutable Data Structures</strong> <br /> 1. Zero side-effects <br /> 2. Immutable data objects are simpler to create, test, and use <br /> 3. Helps prevent temporal coupling <br /> 4. Easier to track changes <br /> <br /> <strong># Function / Stateless Components and React.PureComponent</strong> <br />  1. Component State/Props is an immutable object <br />  2. State/Props should not have a multi-level nested object  <br />  <br />  <strong># Multiple Chunk Files</strong> <br />  You can consider having two separate files by separating your vendor, or third-party library code from  your application code by taking advantage of CommonsChunkPlugin for webpack. You'll end up with  vendor.bundle.js and app.bundle.js. By splitting your files, your browser caches less frequently and  parallel downloads resources to reduce load time wait.  <br />  <br />  <strong># Using Production Mode Flag in Webpack</strong> <br />  If you are using webpack 4 as a module bundler for your app, you can consider setting the mode option to  production. This basically tells webpack to use the built-in optimization  <br />  <br />  <strong># Dependency optimization</strong> <br />  When considering optimizing the application bundle size, it's worth checking how much code you are  actually utilizing from dependencies. For example, you could be using Moment.js which includes localized  files for multi-language support. If you don't need to support multiple languages, then you can consider  using moment-locales-webpack-plugin to remove unused locales for your final bundle.  <br />  <br />  <strong># Spreading props on DOM elements</strong> <br />  You should avoid spreading properties into a DOM element as it adds unknown HTML attribute, which is  unnecessary and a bad practice.  <br />  <br />  <strong># Use Reselect in Redux to Avoid Frequent Re-render</strong> <br />  Reselect is a simple selector library for Redux, which can be used for building memorized selectors. You  can define selectors as a function, retrieving snippets of the Redux state for React components."
   }
]
